---
title: "Generative art workflow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(arttools)
```

The assumption underpinning the package is that your generative art workflow is something along these lines. First you write some code defining the generative art system, and second (or more likely, concurrently) you generate many image files using this system. Next, you want to take some subset of those images and host them online somewhere, so that you can then create an art portfolio website that displays those images. Over time, you're probably going to end up writing lots of generative art systems so you will end up needing to repeat this cycle many time.

If that's the workflow you have in mind, it's helpful to see that for every generative art system you create there are four distinct "components" that come out of it:

1. Source code, and other inputs that define the system
2. Raw output images created by the system
3. Curated images that you want to share 
4. Webpage that displays the curated images

These components can (and generally do) live in different locations, and can have both local copies and remote copies. Once you have many art systems it's really easy to end up with a mess of inconsistent decisions about where things live, which eventually makes your life harder. It helps to take a systematic approach.

The arttools package is very opinionated about how components should be structured. That's not surprising -- it's opinionated because it's designed for my personal workflow! So where do they live?

1. Source code and other inputs live in git **repositories**
2. Raw output images are ephemeral: they exist only as local files
3. Curated images that you want to keep/share live in a cloud storage **bucket**

I'll talk about the portfolio website later, but the assumption here is that this site exists merely to hotlink to the curated images stored in the bucket: it doesn't store copies of the images itself. As such the expectation is that this lives whereever you would normally store a website. In my case, that means that the art website lives in a git repository and is published using GitHub Pages, Netlify, or something like that.

### Repository paths

The first assumption is that generative art code for a system is placed under version control, and it lives in a git repository (e.g., on GitHub). These git repositories have *remote* paths (where are they on GitHub) and *local* paths (where are they on this machine). To help manage these locations arttools has convenience functions `repo_remote_path()` and `repo_local_path()`. To use these, we'd have something like this in the .Rprofile file:

```{r}
options(
  arttools.repos.remote = "https://github.com/djnavarro",
  arttools.repos.local = "/home/danielle/GitHub"
)
```

Supposing I have generative art systems in a repositories called "series-cards" and "series-boxes", I can build paths to the local copies like this:

```{r}
#| results: hold
repo_local_path("series-cards")
repo_local_path("series-boxes")
```

Along the same lines, I can get their remote locations:

```{r}
#| results: hold
repo_remote_path("series-cards")
repo_remote_path("series-boxes")
```

### Bucket paths

The second assumption is that image files created by the generative art system *don't* belong in a git repository. It's grossly typical to create an extremely large number of images and some of those image files can be rather large. Usually we try to avoid placing output files and binary files under version control! Instead we'll use a cloud storage bucket (in my case, on Google Cloud Storage), and again we have helper functions to manage paths:


```{r}
options(
  arttools.bucket.remote = "https://storage.googleapis.com/djnavarro-art",
  arttools.bucket.local = "/home/danielle/Buckets/djnavarro-art"
)
```

Local paths look like this:

```{r}
#| results: hold
bucket_local_path("series-cards")
bucket_local_path("series-boxes")
```

Remote paths look like this:

```{r}
#| results: hold
bucket_remote_path("series-cards")
bucket_remote_path("series-boxes")
```


### Repository name

One of the first choices you have to make when setting up a new system is to choose a name for the repository. The arttools package doesn't enforce any naming system, but from my personal experience I've learned that it's useful to adopt a consistent `[prefix]-[system name]` format. All my art repositories use "series" as a prefix, which makes it a lot easier for me to find them on GitHub later! For example, if my generative art system is called "cards", the repository name would be "series-cards". Any time a function in the arttools package takes a `series` argument, I'd write `series = "series-cards"` or something along those lines.

There's nothing special about using "series" as the prefix though. I chose that solely because of how I think about generative art systems: to me they're tools for creating an "art series", so that seems to make sense to me.

### Repository folder structure

You can use `repo_create()` to create the skeleton for a local series repository. If my generative art system is called "fake", my series name will be `"series-fake"`. I might use a command like this to create a skeleton:

```{r}
repo_create(
  series = "series-fake",
  license = "ccby",
  destination = tempdir()
)
```

Note that the `destination = tempdir()` part is purely for the sake of this article. By default, the `repo_create()` function assumes you want to create the skeleton in the same local folder that you have all your other art repositories, and as such the default value of `destination = repo_local_path()` is probably what you actually want. This is the file tree it creates:

```{r}
#| echo: false
series_path <- fs::path(tempdir(), "series-fake")
fs::dir_tree(
  series_path, 
  all = TRUE, 
  recurse = TRUE
)
```

```{r}
#| echo: false
#| results: hide
fs::dir_delete(series_path)
```

Note that:

- It writes a `.gitignore` file to ensure git won't commit output files
- It writes a `.here` file to ensure `here::here()` will always work

But also note that:

- It doesn't create an RStudio project: use `usethis::create_project()` for that
- It doesn't initialise a git repository: use `usethis::use_git()` for that
- It doesn't create a remote on GitHub: use `usethis::use_github()` for that

The structure of this skeleton is as follows (and documented in the `README.md`) file. There are three folders that will be tracked by git:

- `source` should contain source code for the generative art system
- `input` should contain other input files used by the system (optional)
- `build` should contain ancillary scripts that are not part of the art system (optional)

In practice I find that I don't always need the `input` and `build` folders and often delete them. The other two folders are used to store image files. These are:

- `output` is intended for raw output files generated directly by the system
- `series-fake` id intended for the manually curated versions of the output files, and is the folder that you'd later move into cloud storage once you're done with the system 

Both of these are listed in the `.gitignore` file to prevent you from accidentally placing image files under version control. 

The top-level files are:

- `.gitignore` is always created
- `.here` is always created
- `README.md` is always created
- `LICENSE.md` is created only if the `license` argument is specified

Finally, notice that within the source folder there are three other files:

- `source/common.R`
- `source/my-art-system_001.R`
- `source/my-art-system_002.R`

These files define a simple generative art system that I'll use to discuss other aspects of generative art workflow.

### Source versioning 

- From the beginning, assume that you'll iteratively modify the system. So, in addition to having a "system identifier" that provides a name for the system, there should be a "system version" string `sys_ver`. Use left-padded zeros, and number sequentially: `"001"`, `"002"`, etc. (I use three-digit strings here: I've never gone above 80 versions of a single system, so a three-digit code should be safe)
- Keep separate source files for each new version of the system, incrementing the version number every time you experiment with something new:

  ```
  subdivision_001.R
  subdivision_002.R
  subdivision_003.R
  etc.
  ```

### Seed choice

- Use five-digit numbers for the seeds. That should ensure that even in the most extravagant situation where we generate large numbers of output files, we can ensure that output files always sort in numerical seed order and have the same length. 

### Output file names

- Source files should write image files to the `output` directory
- Every output file should record the RNG `seed` used to produce it
- Output files should follow this naming convention:

  ```
  [system]_[version]_[seed].[file extension]
  ```

  As an example:
  
  ```
  subdivision_012_22490.png
  ```
  
### Ignored files

- The `output` folder should be listed in `.gitignore` and not committed
- A separate "gallery" folder, also called `series-[system identifier]` should be used to prepare the files that should be published. This will be a manual curation process, copying a subset of generated images from the `output` folder to the gallery folder. 
- The gallery folder should also be listed in `.gitignore`.

### Build files

- `build_previews.R`: generates smaller-resolution preview images
- `build_manifest.R`: writes the manifest.csv file to the gallery folder

To do:
 
- There should be a `Makefile` that handles the build step, and *only* the build step. It's there to manage the `series-subdivision` (or whatever) folder, *after* we've done the manual curation step and chosen which image files should be published

### The manifest file

A csv file containing the following fields:

- `path`: path to the image file (e.g., `"800/subdivision_012_22490.png"`)
- `resolution`: the image resolution in pixels (if not square, use the largest dimension)
- `series`: the system name (e.g., `"subdivision"`)
- `sys_id`: the system version string (e.g, `"012"`)
- `img_id`: the image identifier, usually just the seed (e.g. `"22490"`)
- `format`: the file extension (e.g., `"png"`)
- `date`: the publication date in YYYY-MM-DD format (e.g. `"2023-06-02"`)

To do:

- Manifests should also have a `manifest_version` field so that if I later change the manifest format the reader can work out how to handle the manifest by inspecting that field

### System name changes

It's grossly typical that we choose a new name at the end of the process. Solution to this is to make it "superficial only". That is:

- Don't rename source files
- Don't rename the system ids etc within source files
- Don't rename the output file

But we:

- Do rename the repository on github (e.g., from `series-rectangles` to `series-subdivision`)
- Do rename the gallery folder (again, e.g., from `series-rectangles` to `series-subdivision`)
- Use the new name in the `_gallery.csv` file

It's not ideal, but it minimises mess, and ultimately ensures that the thing that gets published uses the correct name on the art website and on github. It also has the nice property of preserving redirects on github.

### Publishing images to cloud storage

- Optional, but desirable: move (or copy) the gallery folder to the `~/Bucket/djnavarro-art` folder. Gallery folders properly belong to the object store rather than the git repo, so we might as well have that reflected locally!
- To publish a gallery folder, copy it to the `djnavarro-art` bucket on google cloud storage using the `series-upload.sh` script. For instance:

  ```
  ./series-upload.sh series-subdivision
  ```
  
  The actual script:

  ```
  #! /bin/bash
  FOLDER=$1;
  gcloud storage cp $FOLDER gs://djnavarro-art --recursive --project generative-art-389407
  ```

### Updating the website



